
* Point Location Wrong

** Repeatable Cause
1. Start emacs -Q
2. Delete the word "buffer"
3. Move up a couple of lines, and delete the word "want".
4. undo
5. Point will be left at where you deleted the word "buffer".

> Also, can you try:
>
> (setq undo-auto--current-boundary-timer t)
>
> and see if that stops it.

No. Still same thing.


* Before Change

** Without undo

Value: (nil
 (#("want" 0 4
    (fontified t face font-lock-comment-face))
  . 39)
 (#<marker at 39 in *scratch*> . -4)
 (#<marker at 39 in *scratch*> . -1)
 (#<marker in no buffer> . -4)
 (#<marker in no buffer> . -4)
 43 
 nil
 (#("buffer" 0 6
    (fontified t face font-lock-comment-face))
  . 183)
 (#<marker at 39 in *scratch*> . -6)
 (#<marker at 179 in *scratch*> . -4)
 (#<marker at 179 in *scratch*> . -4)
 (#<marker in no buffer> . -6)
 (#<marker in no buffer> . -6)
 189
 (t . 0)
 nil
 (1 . 192)
 (t . 0))


** With Undo


 (nil
 (39 . 43)
 nil
 (#("want" 0 4
    (fontified t face font-lock-comment-face))
  . 39)
 (#<marker at 43 in *scratch*> . -4)
 (#<marker at 40 in *scratch*> . -1)
 (#<marker in no buffer> . -4)
 (#<marker in no buffer> . -4)
 43 nil
 (#("buffer" 0 6
    (fontified t face font-lock-comment-face))
  . 183)
 (#<marker at 43 in *scratch*> . -6)
 (#<marker at 183 in *scratch*> . -3)
 (#<marker at 183 in *scratch*> . -3)
 (#<marker in no buffer> . -6)
 (#<marker in no buffer> . -6)
 189
 (t . 0)
 nil
 (1 . 192)
 (t . 0))


* After Change

** Without Undo

#+begin_src emacs-lisp
 (nil                                  ;; boundary
 (#("want" 0 4
    (fontified t face font-lock-comment-face))
  . 39)                                ;; text that was deleted
 (#<marker at 39 in *scratch*> . -4)   ;; marker was moved
 (#<marker at 39 in *scratch*> . -2)   ;; marker was moved
 (#<marker in no buffer> . -4)         ;; marker was moved 
 183                                   ;; position of point
 nil                                   ;; boundary
 (#("buffer" 0 6
    (fontified t face font-lock-comment-face))
  . 183)                               ;; text that was deleted
 (#<marker at 39 in *scratch*> . -6)   ;; marker moved
 (#<marker at 179 in *scratch*> . -2)  ;; marker moved
 (#<marker at 179 in *scratch*> . -2)  ;; marker moved
 (#<marker in no buffer> . -6)         ;; marker moved
 (t . 0)                               ;; buffer become modified
 nil                                   ;; boundary
 (1 . 192)                             ;; text inserted (initial message)
 (t . 0))                              ;; buffer become modified
#+end_src

** With Undo

(nil
 (39 . 43)
 nil
 (#("want" 0 4
    (fontified t face font-lock-comment-face))
  . 39)
 (#<marker at 183 in *scratch*> . -4)
 (#<marker at 41 in *scratch*> . -2)
 (#<marker in no buffer> . -4)
 183 nil
 (#("buffer" 0 6
    (fontified t face font-lock-comment-face))
  . 183)
 (#<marker at 183 in *scratch*> . -6)
 (#<marker at 183 in *scratch*> . -2)
 (#<marker at 183 in *scratch*> . -2)
 (#<marker in no buffer> . -6)
 (#<marker in no buffer> . -6)
 (t . 0)
 nil
 (1 . 192)
 (t . 0))


* Investigation

I've added a test case to simple-test.el.

I have tried added an undo-log command. Bizarrely, though the log command 
changes the behaviour.


(defvar undo-log nil)
;;(setq undo-log t)

(defun undo-log (&rest args)
  (when
      undo-log
      (with-current-buffer
          (get-buffer-create "*undo-log*")
        (goto-char (point-max))
        (insert (apply 'format args))
        (insert "\n"))))

With undo-log set to t, my unit test runs correctly. Otherwise it
fails. So, something is very wrong!


Tested further -- adding to a temp-buffer doesn't have the same
effect. So this only works because a undoable change has happened in
*undo-log*.

So, if we move this code up the stack till it stops working, we should
find the error.

(defvar undo-test nil)

(defun undo-test-change()
 (when undo-test
   (with-current-buffer
        (get-buffer-create "*undo-log*")
      (insert "a"))))
    
Test undo-auto--boundaries -- works



So this code is worrying...

(defun undo-auto--add-boundary ()
  "Add an `undo-boundary' in appropriate buffers."
  (undo-auto--boundaries
   (if undo-auto--this-command-amalgamating
       'amalgamate
     'command))
  (setq undo-auto--this-command-amalgamating nil))

If another --add-boundary is signallyed as a result of this command,
the --this-command-amalgamating will not have been reset to nil, so
that command may be amagamating also? Perhaps we should set to nil
before we call 

(defun undo-auto--add-boundary ()
  "Add an `undo-boundary' in appropriate buffers."
  (undo-auto--boundaries
   (let ((amal undo-auto--this-command-amalgamating))
       (setq undo-auto--this-command-amalgamating nil)
       (if amal
           'amalgamate
         'command))))


Tried that -- nicer perhaps, but makes no difference.


** buffer-undo-list

It's this line that is wrong -- the 183 should be 43. So, we have a
problem with record_point I think.

 (#<marker in no buffer> . -4)         ;; marker was moved 
 183                                   ;; position of point
 nil                                   ;; boundary


The value comes from last_boundary_position.

This is set in undo-boundary

  last_boundary_position = PT;
  last_boundary_buffer = current_buffer;

So, if a boundary is added in another buffer this all changes.

  if (at_boundary
      && current_buffer == last_boundary_buffer
      && last_boundary_position != pt)
    bset_undo_list (current_buffer,
		    Fcons (make_number (last_boundary_position),
			   BVAR (current_buffer, undo_list)));


Hence the bug. Not quite sure, why the bug fixes things. But, either
way, we need a new way of storing this data which is not dependent on
the buffer before the last.

last_boundary_position should be local?


** Walk Though of old undo

Need to read this though backwards!

#+begin_src emacs-lisp
  (nil
   (#("want" 0 4
      (fontified t face font-lock-comment-face))
    . 39)
   (#<marker at 39 in *scratch*> . -4)
   (#<marker at 39 in *scratch*> . -1)
   (#<marker in no buffer> . -4)
   (#<marker in no buffer> . -4)
   43
   nil
   (#("buffer" 0 6
      (fontified t face font-lock-comment-face))
    . 183)
   (#<marker at 39 in *scratch*> . -6)
   (#<marker at 179 in *scratch*> . -4)
   (#<marker at 179 in *scratch*> . -4)
   (#<marker in no buffer> . -6)
   (#<marker in no buffer> . -6)
   ;; we (were) at the boundary, the last_boundary_buffer was
   189
   ;; We are about to delete so record_first_change adds this called
   ;; from within record_point
   (t . 0)
   ;; undo-boundary -- last_boundary_position will be set to 192
   ;; presumably?
   nil
   ;; text inserted -- 192 is after blurb and two new lines
   (1 . 192)
   ;; text modified the first time
   (t . 0))
#+end_src



So, we only actually record point in this way before a delete, and
only from one of the two calls from record_delete

So, we can rewrite record_point into two functions


* Stefan

>     PT is the position of point that will naturally occur as a result of the
>     undo record that will be added just after this command terminates.  */

This comment is invalidated by your change.

> +      record_point (beg + SCHARS (string));

Hmm I thought the sign on sbeg took care of this case already (i.e. the
record_point should only record something when point was neither at the
beginning nor at the end of the deleted string).

As for the source of the bug (i.e. what change caused the new behavior):
in the old code, undo-boundary was called right before every command
(whether there was a need to push a boundary or not), so contrary to the
comment in the code, last_boundary_position was actually recording
"position of point at beginning of the command" rather than "position of
point last time we inserted a boundary".

So the hunk below should recover the old behavior (well, more or less:
it wouldn't compile as is, but I hope you get the idea).  But to fix it
right, we should rename these vars and adjust their comment to better
reflect the way they're really used.


        Stefan


diff --git a/src/keyboard.c b/src/keyboard.c
index 849066c..125091e 100644
--- a/src/keyboard.c
+++ b/src/keyboard.c
@@ -1448,6 +1448,8 @@ command_loop_1 (void)
             /* Ensure that we have added appropriate undo-boundaries as a
                result of changes from the last command. */
             call0 (Qundo_auto__add_boundary);
+            last_boundary_position = PT;
+            last_boundary_buffer = current_buffer;

             call1 (Qcommand_execute, Vthis_command);



But how does this solve the problem where things change in other bufers?

It doesn't -- but that is more complicated, so don't worry.

Are these things not already available here?


      prev_buffer = current_buffer;
      prev_modiff = MODIFF;
      last_point_position = PT;
